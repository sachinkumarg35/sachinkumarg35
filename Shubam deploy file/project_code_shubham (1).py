# -*- coding: utf-8 -*-
"""project code shubham.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YWE0CSouJXfPqu8STs-j_kaS-BwJcXLY
"""

#@title
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.holtwinters import Holt # Holts Exponential Smoothing
from statsmodels.tsa.holtwinters import ExponentialSmoothing # 
import pickle
from datetime import datetime,time

# Importing uploaded data
#df = pd.read_csv("Beds_Occupied.csv")
df = Beds_Occupied.copy()
# The main objective is to decide the availability of the beds but we have been provided with the data of occupied beds
# We know that there are total of 900 beds so we can create column which will directly shows us the available number of beds.
df["beds_available"] = 900-df["Total Inpatient Beds"]

# Let's create new dataframe only with the date and availability data
new_df = df.iloc[:,[0,2]]

# Creating the Date column to store the actual date format for the given month
new_df["date"] = pd.to_datetime(new_df.collection_date, format = "%d-%m-%Y")

# Extracting days, weeks, months and years from the date given
new_df["days"] = new_df.date.dt.strftime("%d")
new_df["day_name"] = new_df.date.dt.strftime("%A")
new_df["weeks"] = new_df.date.dt.strftime("%w")
new_df["months"] = new_df.date.dt.strftime("%b")
new_df["years"] = new_df.date.dt.strftime("%Y")

# Converting the index into data time format as it is required for decomposition plot
new_df = new_df.set_index('date')
new_df.sort_index(inplace = True)

# Adding the missing dates (Imputing the missing dates)
r = pd.date_range("15-06-2020","15-06-2021")
newdata = new_df.reindex(r).reset_index()

# Filling the missing values in place of NaN
# Filling the missing values after finding them using forecasting method.
newdata.iloc[164,1] = "26-11-2020"
newdata.iloc[165,1] = "27-11-2020"
newdata.iloc[166,1] = "28-11-2020"
newdata.iloc[167,1] = "29-11-2020"
newdata.iloc[333,1] = "14-05-2021"
newdata.iloc[334,1] = "15-05-2021"
newdata.iloc[335,1] = "16-05-2021"

newdata.iloc[31,2] = 609.855346
newdata.iloc[164,2] = 674.678545
newdata.iloc[165,2] = 678.525015
newdata.iloc[166,2] = 683.317539
newdata.iloc[167,2] = 667.964678
newdata.iloc[333,2] = 678.146041
newdata.iloc[334,2] = 674.102198
newdata.iloc[335,2] = 658.948666

#Split newdata into train and test
newdata_train = newdata.head(331)
newdata_test = newdata.tail(35)

# Here I have created Standard train and test datasets so even if I changed the data for model building I don't have to make changes in the model itself
# So we will use these dataset's names throughout the models but we will change the data it them to our requirments
train = newdata_train
test = newdata_test

# Holts winter exponential smoothing with miltiplicative seasonality and additive trend
hwe_model_mul_add = ExponentialSmoothing(train["beds_available"],seasonal="mul",trend="add",seasonal_periods = 7).fit()
#pred_hwe_mul_add = hwe_model_mul_add.predict(start = newdata.index[0],end = newdata.index[-1])
#pred_hwe_mul_add_train = hwe_model_mul_add.predict(start = train.index[0],end = train.index[-1])
#pred_hwe_mul_add_test = hwe_model_mul_add.predict(start = test.index[0],end = test.index[-1])

# mape_hwe_mul_add = MAPE(pred_hwe_mul_add,test.beds_available)
# MAPE(pred_hwe_mul_add,test.beds_available)

#rmse_hwe_mul_add = np.sqrt(np.mean((np.array(newdata["beds_available"])-np.array(pred_hwe_mul_add))**2))

#rmse_hwe_mul_add_train = np.sqrt(np.mean((np.array(train["beds_available"])-np.array(pred_hwe_mul_add_train))**2))

#rmse_hwe_mul_add_test = np.sqrt(np.mean((np.array(test["beds_available"])-np.array(pred_hwe_mul_add_test))**2))

#print(rmse_hwe_mul_add, rmse_hwe_mul_add_train, rmse_hwe_mul_add_test)

#f = plt.figure()
#f.set_figwidth(25)
#f.set_figheight(4)
#
#plt.plot(pred_hwe_mul_add)
#plt.plot(pred_hwe_mul_add_train)
#plt.plot(pred_hwe_mul_add_test)
#plt.plot(train['beds_available'])
#plt.plot(test['beds_available'])

# Saving model to disk
pickle.dump(hwe_model_mul_add, open('model.pkl', 'wb'))

# Loading model to compare the results
model = pickle.load(open('model.pkl', 'rb'))
print(model.forecast(steps = 3))
